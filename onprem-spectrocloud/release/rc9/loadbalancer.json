{
  "metadata": {
    "name": "_ddp_prefix-ddp-lb",
    "description": "",
    "labels": {
      "owner": "ddp"
    }
  },
  "spec": {
    "version": "1.0.0-rc9",
    "template": {
      "type": "add-on",
      "cloudType": "all",
      "packs": [
        {
          "name": "lb-metallb",
          "type": "spectro",
          "layer": "addon",
          "version": "0.13.7",
          "tag": "0.13.x",
          "values": "pack:\n  spectrocloud.com/install-priority: \"0\"\nmanifests:\n  metallb:\n    namespace: \"metallb-system\"\n    avoidBuggyIps: true\n    addresses:\n      - \"{{.spectro.macro._ddp_prefix-metallb_ip_list}}\"",
          "registry": {
            "metadata": {
              "uid": "0.9.0",
              "name": "Public Repo",
              "kind": "pack",
              "isPrivate": false
            }
          }
        },
        {
          "name": "nginx",
          "type": "spectro",
          "layer": "addon",
          "version": "1.5.1",
          "tag": "1.5.x",
          "values": "pack:\n  content:\n    images:\n      - image: ingress-nginx/controller:v1.5.1\n    charts:\n      - repo: https://kubernetes.github.io/ingress-nginx\n        name: ingress-nginx\n        version: v1.5.1\n  namespace: \"nginx\"\n  spectrocloud.com/install-priority: \"2\"\ncharts:\n  ingress-nginx:\n    fullnameOverride: \"nginx-ingress\"\n    controller:\n      name: controller\n      image:\n        ## Keep false as default for now!\n        chroot: false\n        registry: registry.k8s.io\n        image: ingress-nginx/controller\n        ## for backwards compatibility consider setting the full image url via the repository value below\n        ## use *either* current default registry/image or repository format or installing chart by providing the values.yaml will fail\n        ## repository:\n        tag: \"v1.5.1\"\n        digest: sha256:4ba73c697770664c1e00e9f968de14e08f606ff961c76e5d7033a4a9c593c629\n        digestChroot: sha256:c1c091b88a6c936a83bd7b098662760a87868d12452529bad0d178fb36147345\n        pullPolicy: IfNotPresent\n        # www-data -> uid 101\n        runAsUser: 101\n        allowPrivilegeEscalation: true\n      # -- Use an existing PSP instead of creating one\n      existingPsp: \"\"\n      # -- Configures the controller container name\n      containerName: controller\n      # -- Configures the ports that the nginx-controller listens on\n      containerPort:\n        http: 80\n        https: 443\n      # -- Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/\n      config: {}\n      # -- Annotations to be added to the controller config configuration configmap.\n      configAnnotations: {}\n      # -- Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers\n      proxySetHeaders: {}\n      # -- Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers\n      addHeaders: {}\n      # -- Optionally customize the pod dnsConfig.\n      dnsConfig: {}\n      # -- Optionally customize the pod hostname.\n      hostname: {}\n      # -- Optionally change this to ClusterFirstWithHostNet in case you have 'hostNetwork: true'.\n      # By default, while using host network, name resolution uses the host's DNS. If you wish nginx-controller\n      # to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.\n      dnsPolicy: ClusterFirst\n      # -- Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network\n      # Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply\n      reportNodeInternalIp: false\n      # -- Process Ingress objects without ingressClass annotation/ingressClassName field\n      # Overrides value for --watch-ingress-without-class flag of the controller binary\n      # Defaults to false\n      watchIngressWithoutClass: false\n      # -- Process IngressClass per name (additionally as per spec.controller).\n      ingressClassByName: false\n      # -- This configuration defines if Ingress Controller should allow users to set\n      # their own *-snippet annotations, otherwise this is forbidden / dropped\n      # when users add those annotations.\n      # Global snippets in ConfigMap are still respected\n      allowSnippetAnnotations: true\n      # -- Required for use with CNI based kubernetes installations (such as ones set up by kubeadm),\n      # since CNI and hostport don't mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920\n      # is merged\n      hostNetwork: false\n      ## Use host ports 80 and 443\n      ## Disabled by default\n      hostPort:\n        # -- Enable 'hostPort' or not\n        enabled: false\n        ports:\n          # -- 'hostPort' http port\n          http: 80\n          # -- 'hostPort' https port\n          https: 443\n      # -- Election ID to use for status update, by default it uses the controller name combined with a suffix of 'leader'\n      electionID: \"\"\n      ## This section refers to the creation of the IngressClass resource\n      ## IngressClass resources are supported since k8s >= 1.18 and required since k8s >= 1.19\n      ingressClassResource:\n        # -- Name of the ingressClass\n        name: nginx\n        # -- Is this ingressClass enabled or not\n        enabled: true\n        # -- Is this the default ingressClass for the cluster\n        default: true\n        # -- Controller-value of the controller that is processing this ingressClass\n        controllerValue: \"k8s.io/ingress-nginx\"\n        # -- Parameters is a link to a custom resource containing additional\n        # configuration for the controller. This is optional if the controller\n        # does not require extra parameters.\n        parameters: {}\n      # -- For backwards compatibility with ingress.class annotation, use ingressClass.\n      # Algorithm is as follows, first ingressClassName is considered, if not present, controller looks for ingress.class annotation\n      ingressClass: nginx\n      # -- Labels to add to the pod container metadata\n      podLabels: {}\n      #  key: value\n\n      # -- Security Context policies for controller pods\n      podSecurityContext: {}\n      # -- See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls\n      sysctls: {}\n      # sysctls:\n      #   \"net.core.somaxconn\": \"8192\"\n\n      # -- Allows customization of the source of the IP address or FQDN to report\n      # in the ingress status field. By default, it reads the information provided\n      # by the service. If disable, the status field reports the IP address of the\n      # node or nodes where an ingress controller pod is running.\n      publishService:\n        # -- Enable 'publishService' or not\n        enabled: true\n        # -- Allows overriding of the publish service to bind to\n        # Must be <namespace>/<service_name>\n        pathOverride: \"\"\n      # Limit the scope of the controller to a specific namespace\n      scope:\n        # -- Enable 'scope' or not\n        enabled: false\n        # -- Namespace to limit the controller to; defaults to $(POD_NAMESPACE)\n        namespace: \"\"\n        # -- When scope.enabled == false, instead of watching all namespaces, we watching namespaces whose labels\n        # only match with namespaceSelector. Format like foo=bar. Defaults to empty, means watching all namespaces.\n        namespaceSelector: \"\"\n      # -- Allows customization of the configmap / nginx-configmap namespace; defaults to $(POD_NAMESPACE)\n      configMapNamespace: \"\"\n      tcp:\n        # -- Allows customization of the tcp-services-configmap; defaults to $(POD_NAMESPACE)\n        configMapNamespace: \"\"\n        # -- Annotations to be added to the tcp config configmap\n        annotations: {}\n      udp:\n        # -- Allows customization of the udp-services-configmap; defaults to $(POD_NAMESPACE)\n        configMapNamespace: \"\"\n        # -- Annotations to be added to the udp config configmap\n        annotations: {}\n      # -- Maxmind license key to download GeoLite2 Databases.\n      ## https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases\n      maxmindLicenseKey: \"\"\n      # -- Additional command line arguments to pass to nginx-ingress-controller\n      # E.g. to specify the default SSL certificate you can use\n      extraArgs: {}\n      ## extraArgs:\n      ##   default-ssl-certificate: \"<namespace>/<secret_name>\"\n\n      # -- Additional environment variables to set\n      extraEnvs: []\n      # extraEnvs:\n      #   - name: FOO\n      #     valueFrom:\n      #       secretKeyRef:\n      #         key: FOO\n      #         name: secret-resource\n\n      # -- Use a `DaemonSet` or `Deployment`\n      kind: Deployment\n      # -- Annotations to be added to the controller Deployment or DaemonSet\n      ##\n      annotations: {}\n      #  keel.sh/pollSchedule: \"@every 60m\"\n\n      # -- Labels to be added to the controller Deployment or DaemonSet and other resources that do not have option to specify labels\n      ##\n      labels: {}\n      #  keel.sh/policy: patch\n      #  keel.sh/trigger: poll\n\n\n      # -- The update strategy to apply to the Deployment or DaemonSet\n      ##\n      updateStrategy: {}\n      #  rollingUpdate:\n      #    maxUnavailable: 1\n      #  type: RollingUpdate\n\n      # -- `minReadySeconds` to avoid killing pods before we are ready\n      ##\n      minReadySeconds: 0\n      # -- Node tolerations for server scheduling to nodes with taints\n      ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n      ##\n      tolerations: []\n      #  - key: \"key\"\n      #    operator: \"Equal|Exists\"\n      #    value: \"value\"\n      #    effect: \"NoSchedule|PreferNoSchedule|NoExecute(1.6 only)\"\n\n      # -- Affinity and anti-affinity rules for server scheduling to nodes\n      ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity\n      ##\n      affinity: {}         \n      # -- Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in.\n      ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\n      ##\n      topologySpreadConstraints: []         \n      # -- `terminationGracePeriodSeconds` to avoid killing pods before we are ready\n      ## wait up to five minutes for the drain of connections\n      ##\n      terminationGracePeriodSeconds: 300\n      # -- Node labels for controller pod assignment\n      ## Ref: https://kubernetes.io/docs/user-guide/node-selection/\n      ##\n      nodeSelector:\n        kubernetes.io/os: linux\n      ## Liveness and readiness probe values\n      ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes\n      ##\n      ## startupProbe:\n      ##   httpGet:\n      ##     # should match container.healthCheckPath\n      ##     path: \"/healthz\"\n      ##     port: 10254\n      ##     scheme: HTTP\n      ##   initialDelaySeconds: 5\n      ##   periodSeconds: 5\n      ##   timeoutSeconds: 2\n      ##   successThreshold: 1\n      ##   failureThreshold: 5\n      livenessProbe:\n        httpGet:\n          # should match container.healthCheckPath\n          path: \"/healthz\"\n          port: 10254\n          scheme: HTTP\n        initialDelaySeconds: 10\n        periodSeconds: 10\n        timeoutSeconds: 1\n        successThreshold: 1\n        failureThreshold: 5\n      readinessProbe:\n        httpGet:\n          # should match container.healthCheckPath\n          path: \"/healthz\"\n          port: 10254\n          scheme: HTTP\n        initialDelaySeconds: 10\n        periodSeconds: 10\n        timeoutSeconds: 1\n        successThreshold: 1\n        failureThreshold: 3\n      # -- Path of the health check endpoint. All requests received on the port defined by\n      # the healthz-port parameter are forwarded internally to this path.\n      healthCheckPath: \"/healthz\"\n      # -- Address to bind the health check endpoint.\n      # It is better to set this option to the internal node address\n      # if the ingress nginx controller is running in the `hostNetwork: true` mode.\n      healthCheckHost: \"\"\n      # -- Annotations to be added to controller pods\n      ##\n      podAnnotations: {}\n      replicaCount: 1\n      # -- Define either 'minAvailable' or 'maxUnavailable', never both.\n      minAvailable: 1\n      # -- Define either 'minAvailable' or 'maxUnavailable', never both.\n      # maxUnavailable: 1\n\n      ## Define requests resources to avoid probe issues due to CPU utilization in busy nodes\n      ## ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903\n      ## Ideally, there should be no limits.\n      ## https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/\n      resources:\n        ##  limits:\n        ##    cpu: 100m\n        ##    memory: 90Mi\n        requests:\n          cpu: 100m\n          memory: 90Mi\n      # Mutually exclusive with keda autoscaling\n      autoscaling:\n        apiVersion: autoscaling/v2\n        enabled: false\n        annotations: {}\n        minReplicas: 1\n        maxReplicas: 11\n        targetCPUUtilizationPercentage: 50\n        targetMemoryUtilizationPercentage: 50\n        behavior: {}           \n      autoscalingTemplate: []\n      # Custom or additional autoscaling metrics\n      # ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics\n      # - type: Pods\n      #   pods:\n      #     metric:\n      #       name: nginx_ingress_controller_nginx_process_requests_total\n      #     target:\n      #       type: AverageValue\n      #       averageValue: 10000m\n\n      # Mutually exclusive with hpa autoscaling\n      keda:\n        apiVersion: \"keda.sh/v1alpha1\"\n        ## apiVersion changes with keda 1.x vs 2.x\n        ## 2.x = keda.sh/v1alpha1\n        ## 1.x = keda.k8s.io/v1alpha1\n        enabled: false\n        minReplicas: 1\n        maxReplicas: 11\n        pollingInterval: 30\n        cooldownPeriod: 300\n        restoreToOriginalReplicaCount: false\n        scaledObject:\n          annotations: {}\n          # Custom annotations for ScaledObject resource\n          #  annotations:\n          # key: value\n        triggers: []\n        #     - type: prometheus\n        #       metadata:\n        #         serverAddress: http://<prometheus-host>:9090\n        #         metricName: http_requests_total\n        #         threshold: '100'\n        #         query: sum(rate(http_requests_total{deployment=\"my-deployment\"}[2m]))\n\n        behavior: {}\n      #     scaleDown:\n      #       stabilizationWindowSeconds: 300\n      #       policies:\n      #       - type: Pods\n      #         value: 1\n      #         periodSeconds: 180\n      #     scaleUp:\n      #       stabilizationWindowSeconds: 300\n      #       policies:\n      #       - type: Pods\n      #         value: 2\n      #         periodSeconds: 60\n\n      # -- Enable mimalloc as a drop-in replacement for malloc.\n      ## ref: https://github.com/microsoft/mimalloc\n      ##\n      enableMimalloc: true\n      ## Override NGINX template\n      customTemplate:\n        configMapName: \"\"\n        configMapKey: \"\"\n      service:\n        enabled: true\n        # -- If enabled is adding an appProtocol option for Kubernetes service. An appProtocol field replacing annotations that were\n        # using for setting a backend protocol. Here is an example for AWS: service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http\n        # It allows choosing the protocol for each backend specified in the Kubernetes service.\n        # See the following GitHub issue for more details about the purpose: https://github.com/kubernetes/kubernetes/issues/40244\n        # Will be ignored for Kubernetes versions older than 1.20\n        ##\n        appProtocol: true\n        annotations: {}\n        labels: {}\n        # clusterIP: \"\"\n\n        # -- List of IP addresses at which the controller services are available\n        ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n        ##\n        externalIPs: []\n        # -- Used by cloud providers to connect the resulting `LoadBalancer` to a pre-existing static IP according to https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer\n        loadBalancerIP: \"{{ .spectro.macro._ddp_prefix-nginx_loadbalancer_ip }}\"\n        loadBalancerSourceRanges: []\n        enableHttp: true\n        enableHttps: true\n        ## Set external traffic policy to: \"Local\" to preserve source IP on providers supporting it.\n        ## Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer\n        # externalTrafficPolicy: \"\"\n\n        ## Must be either \"None\" or \"ClientIP\" if set. Kubernetes will default to \"None\".\n        ## Ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n        # sessionAffinity: \"\"\n\n        ## Specifies the health check node port (numeric port number) for the service. If healthCheckNodePort isn’t specified,\n        ## the service controller allocates a port from your cluster’s NodePort range.\n        ## Ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip\n        # healthCheckNodePort: 0\n\n        # -- Represents the dual-stack-ness requested or required by this Service. Possible values are\n        # SingleStack, PreferDualStack or RequireDualStack.\n        # The ipFamilies and clusterIPs fields depend on the value of this field.\n        ## Ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/\n        ipFamilyPolicy: \"SingleStack\"\n        # -- List of IP families (e.g. IPv4, IPv6) assigned to the service. This field is usually assigned automatically\n        # based on cluster configuration and the ipFamilyPolicy field.\n        ## Ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/\n        ipFamilies:\n          - IPv4\n        ports:\n          http: 80\n          https: 443\n        targetPorts:\n          http: http\n          https: https\n        type: LoadBalancer\n        ## type: NodePort\n        ## nodePorts:\n        ##   http: 32080\n        ##   https: 32443\n        ##   tcp:\n        ##     8080: 32808\n        nodePorts:\n          http: \"\"\n          https: \"\"\n          tcp: {}\n          udp: {}\n        external:\n          enabled: true\n        internal:\n          # -- Enables an additional internal load balancer (besides the external one).\n          enabled: false\n          # -- Annotations are mandatory for the load balancer to come up. Varies with the cloud service.\n          annotations: {}\n          # loadBalancerIP: \"\"\n\n          # -- Restrict access For LoadBalancer service. Defaults to 0.0.0.0/0.\n          loadBalancerSourceRanges: []\n          ## Set external traffic policy to: \"Local\" to preserve source IP on\n          ## providers supporting it\n          ## Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer\n          # externalTrafficPolicy: \"\"\n\n          # shareProcessNamespace enables process namespace sharing within the pod.\n          # This can be used for example to signal log rotation using `kill -USR1` from a sidecar.\n      shareProcessNamespace: false\n      # -- Additional containers to be added to the controller pod.\n      # See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.\n      extraContainers: []\n      #  - name: my-sidecar\n      #    image: nginx:latest\n      #  - name: lemonldap-ng-controller\n      #    image: lemonldapng/lemonldap-ng-controller:0.2.0\n      #    args:\n      #      - /lemonldap-ng-controller\n      #      - --alsologtostderr\n      #      - --configmap=$(POD_NAMESPACE)/lemonldap-ng-configuration\n      #    env:\n      #      - name: POD_NAME\n      #        valueFrom:\n      #          fieldRef:\n      #            fieldPath: metadata.name\n      #      - name: POD_NAMESPACE\n      #        valueFrom:\n      #          fieldRef:\n      #            fieldPath: metadata.namespace\n      #    volumeMounts:\n      #    - name: copy-portal-skins\n      #      mountPath: /srv/var/lib/lemonldap-ng/portal/skins\n\n      # -- Additional volumeMounts to the controller main container.\n      extraVolumeMounts: []\n      #  - name: copy-portal-skins\n      #   mountPath: /var/lib/lemonldap-ng/portal/skins\n\n      # -- Additional volumes to the controller pod.\n      extraVolumes: []\n      #  - name: copy-portal-skins\n      #    emptyDir: {}\n\n      # -- Containers, which are run before the app containers are started.\n      extraInitContainers: []\n      # - name: init-myservice\n      #   image: busybox\n      #   command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']\n\n      # -- Modules, which are mounted into the core nginx image. See values.yaml for a sample to add opentelemetry module\n      extraModules: []\n      #   containerSecurityContext:\n      #     allowPrivilegeEscalation: false\n      #\n      # The image must contain a `/usr/local/bin/init_module.sh` executable, which\n      # will be executed as initContainers, to move its config files within the\n      # mounted volume.\n\n      opentelemetry:\n        enabled: false\n        image: registry.k8s.io/ingress-nginx/opentelemetry:v20221114-controller-v1.5.1-6-ga66ee73c5@sha256:41076fd9fb4255677c1a3da1ac3fc41477f06eba3c7ebf37ffc8f734dad51d7c\n        containerSecurityContext:\n          allowPrivilegeEscalation: false\n      admissionWebhooks:\n        annotations: {}\n        # ignore-check.kube-linter.io/no-read-only-rootfs: \"This deployment needs write access to root filesystem\".\n\n        ## Additional annotations to the admission webhooks.\n        ## These annotations will be added to the ValidatingWebhookConfiguration and\n        ## the Jobs Spec of the admission webhooks.\n        enabled: true\n        # -- Additional environment variables to set\n        extraEnvs: []\n        # extraEnvs:\n        #   - name: FOO\n        #     valueFrom:\n        #       secretKeyRef:\n        #         key: FOO\n        #         name: secret-resource\n        # -- Admission Webhook failure policy to use\n        failurePolicy: Fail\n        # timeoutSeconds: 10\n        port: 8443\n        certificate: \"/usr/local/certificates/cert\"\n        key: \"/usr/local/certificates/key\"\n        namespaceSelector: {}\n        objectSelector: {}\n        # -- Labels to be added to admission webhooks\n        labels: {}\n        # -- Use an existing PSP instead of creating one\n        existingPsp: \"\"\n        networkPolicyEnabled: false\n        service:\n          annotations: {}\n          # clusterIP: \"\"\n          externalIPs: []\n          # loadBalancerIP: \"\"\n          loadBalancerSourceRanges: []\n          servicePort: 443\n          type: ClusterIP\n        createSecretJob:\n          securityContext:\n            allowPrivilegeEscalation: false\n          resources: {}             \n        patchWebhookJob:\n          securityContext:\n            allowPrivilegeEscalation: false\n          resources: {}\n        patch:\n          enabled: true\n          image:\n            registry: registry.k8s.io\n            image: ingress-nginx/kube-webhook-certgen\n            ## for backwards compatibility consider setting the full image url via the repository value below\n            ## use *either* current default registry/image or repository format or installing chart by providing the values.yaml will fail\n            ## repository:\n            tag: v20220916-gd32f8c343\n            digest: sha256:39c5b2e3310dc4264d638ad28d9d1d96c4cbb2b2dcfb52368fe4e3c63f61e10f\n            pullPolicy: IfNotPresent\n          # -- Provide a priority class name to the webhook patching job\n          ##\n          priorityClassName: \"\"\n          podAnnotations: {}\n          nodeSelector:\n            kubernetes.io/os: linux\n          tolerations: []\n          # -- Labels to be added to patch job resources\n          labels: {}\n          securityContext:\n            runAsNonRoot: true\n            runAsUser: 2000\n            fsGroup: 2000\n        # Use certmanager to generate webhook certs\n        certManager:\n          enabled: false\n          # self-signed root certificate\n          rootCert:\n            duration: \"\" # default to be 5y\n          admissionCert:\n            duration: \"\" # default to be 1y\n          # issuerRef:\n          #   name: \"issuer\"\n          #   kind: \"ClusterIssuer\"\n\n      metrics:\n        port: 10254\n        portName: metrics\n        # if this port is changed, change healthz-port: in extraArgs: accordingly\n        enabled: true\n        service:\n          annotations: {}\n          # prometheus.io/scrape: \"true\"\n          # prometheus.io/port: \"10254\"\n\n          # clusterIP: \"\"\n\n          # -- List of IP addresses at which the stats-exporter service is available\n          ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n          ##\n          externalIPs: []\n          # loadBalancerIP: \"\"\n          loadBalancerSourceRanges: []\n          servicePort: 10254\n          type: ClusterIP\n          # externalTrafficPolicy: \"\"\n          # nodePort: \"\"\n\n        serviceMonitor:\n          enabled: false\n          additionalLabels: {}\n          ## The label to use to retrieve the job name from.\n          ## jobLabel: \"app.kubernetes.io/name\"\n          namespace: \"\"\n          namespaceSelector: {}\n          ## Default: scrape .Release.Namespace only\n          ## To scrape all, use the following:\n          ## namespaceSelector:\n          ##   any: true\n          scrapeInterval: 30s\n          # honorLabels: true\n          targetLabels: []\n          relabelings: []\n          metricRelabelings: []\n        prometheusRule:\n          enabled: false\n          additionalLabels: {}\n          # namespace: \"\"\n          rules: []             \n      # -- Improve connection draining when ingress controller pod is deleted using a lifecycle hook:\n      # With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds\n      # to 300, allowing the draining of connections up to five minutes.\n      # If the active connections end before that, the pod will terminate gracefully at that time.\n      # To effectively take advantage of this feature, the Configmap feature\n      # worker-shutdown-timeout new value is 240s instead of 10s.\n      ##\n      lifecycle:\n        preStop:\n          exec:\n            command:\n              - /wait-shutdown\n      priorityClassName: \"\"\n    # -- Rollback limit\n    ##\n    revisionHistoryLimit: 10\n    ## Default 404 backend\n    ##\n    defaultBackend:\n      ##\n      enabled: false\n      name: defaultbackend\n      image:\n        registry: registry.k8s.io\n        image: defaultbackend-amd64\n        ## for backwards compatibility consider setting the full image url via the repository value below\n        ## use *either* current default registry/image or repository format or installing chart by providing the values.yaml will fail\n        ## repository:\n        tag: \"1.5\"\n        pullPolicy: IfNotPresent\n        # nobody user -> uid 65534\n        runAsUser: 65534\n        runAsNonRoot: true\n        readOnlyRootFilesystem: true\n        allowPrivilegeEscalation: false\n      # -- Use an existing PSP instead of creating one\n      existingPsp: \"\"\n      extraArgs: {}\n      serviceAccount:\n        create: true\n        name: \"\"\n        automountServiceAccountToken: true\n      # -- Additional environment variables to set for defaultBackend pods\n      extraEnvs: []\n      port: 8080\n      ## Readiness and liveness probes for default backend\n      ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/\n      ##\n      livenessProbe:\n        failureThreshold: 3\n        initialDelaySeconds: 30\n        periodSeconds: 10\n        successThreshold: 1\n        timeoutSeconds: 5\n      readinessProbe:\n        failureThreshold: 6\n        initialDelaySeconds: 0\n        periodSeconds: 5\n        successThreshold: 1\n        timeoutSeconds: 5\n      # -- Node tolerations for server scheduling to nodes with taints\n      ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n      ##\n      tolerations: []\n      #  - key: \"key\"\n      #    operator: \"Equal|Exists\"\n      #    value: \"value\"\n      #    effect: \"NoSchedule|PreferNoSchedule|NoExecute(1.6 only)\"\n\n      affinity: {}\n      # -- Security Context policies for controller pods\n      # See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for\n      # notes on enabling and using sysctls\n      ##\n      podSecurityContext: {}\n      # -- Security Context policies for controller main container.\n      # See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for\n      # notes on enabling and using sysctls\n      ##\n      containerSecurityContext: {}\n      # -- Labels to add to the pod container metadata\n      podLabels: {}\n      #  key: value\n\n      # -- Node labels for default backend pod assignment\n      ## Ref: https://kubernetes.io/docs/user-guide/node-selection/\n      ##\n      nodeSelector:\n        kubernetes.io/os: linux\n      # -- Annotations to be added to default backend pods\n      ##\n      podAnnotations: {}\n      replicaCount: 1\n      minAvailable: 1\n      resources: {}\n      # limits:\n      #   cpu: 10m\n      #   memory: 20Mi\n      # requests:\n      #   cpu: 10m\n      #   memory: 20Mi\n\n      extraVolumeMounts: []\n      ## Additional volumeMounts to the default backend container.\n      #  - name: copy-portal-skins\n      #   mountPath: /var/lib/lemonldap-ng/portal/skins\n\n      extraVolumes: []\n      ## Additional volumes to the default backend pod.\n      #  - name: copy-portal-skins\n      #    emptyDir: {}\n\n      autoscaling:\n        annotations: {}\n        enabled: false\n        minReplicas: 1\n        maxReplicas: 2\n        targetCPUUtilizationPercentage: 50\n        targetMemoryUtilizationPercentage: 50\n      service:\n        annotations: {}\n        # clusterIP: \"\"\n\n        # -- List of IP addresses at which the default backend service is available\n        ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n        ##\n        externalIPs: []\n        # loadBalancerIP: \"\"\n        loadBalancerSourceRanges: []\n        servicePort: 80\n        type: ClusterIP\n      priorityClassName: \"\"\n      # -- Labels to be added to the default backend resources\n      labels: {}\n    ## Enable RBAC as per https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/rbac.md and https://github.com/kubernetes/ingress-nginx/issues/266\n    rbac:\n      create: true\n      scope: false\n    ## If true, create & use Pod Security Policy resources\n    ## https://kubernetes.io/docs/concepts/policy/pod-security-policy/\n    podSecurityPolicy:\n      enabled: false\n    serviceAccount:\n      create: true\n      name: \"\"\n      automountServiceAccountToken: true\n      # -- Annotations for the controller service account\n      annotations: {}\n    # -- Optional array of imagePullSecrets containing private registry credentials\n    ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/\n    imagePullSecrets: []\n    # - name: secretName\n\n    # -- TCP service key-value pairs\n    ## Ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/exposing-tcp-udp-services.md\n    ##\n    tcp:\n      9001: \"{{.spectro.macro._ddp_prefix-tcp_port9001}}\"\n      9002: \"{{.spectro.macro._ddp_prefix-tcp_port9002}}\"\n      9003: \"{{.spectro.macro._ddp_prefix-tcp_port9003}}\"\n\n    # -- UDP service key-value pairs\n    ## Ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/exposing-tcp-udp-services.md\n    ##\n    udp: {}\n    #  53: \"kube-system/kube-dns:53\"\n\n    # -- Prefix for TCP and UDP ports names in ingress controller service\n    ## Some cloud providers, like Yandex Cloud may have a requirements for a port name regex to support cloud load balancer integration\n    portNamePrefix: \"\"\n    # -- (string) A base64-encoded Diffie-Hellman parameter.\n    # This can be generated with: `openssl dhparam 4096 2> /dev/ | base64`\n    ## Ref: https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/ssl-dh-param\n    dhParam:",
          "registry": {
            "metadata": {
              "uid": "0.9.0",
              "name": "Public Repo",
              "kind": "pack",
              "isPrivate": false
            }
          }
        }
      ]
    }
  }
}
